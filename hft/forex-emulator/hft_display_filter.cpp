/**********************************************************************\
**                                                                    **
**             -=≡≣ High Frequency Trading System ® ≣≡=-              **
**                                                                    **
**          Copyright © 2017 - 2025 by LLG Ryszard Gradowski          **
**                       All Rights Reserved.                         **
**                                                                    **
**  CAUTION! This application is an intellectual property             **
**           of LLG Ryszard Gradowski. This application as            **
**           well as any part of source code cannot be used,          **
**           modified and distributed by third party person           **
**           without prior written permission issued by               **
**           intellectual property owner.                             **
**                                                                    **
\**********************************************************************/

#include <iostream>
#include <unistd.h>

#include <hft_display_filter.hpp>

hft_display_filter::hft_display_filter(void)
    : is_tty_output_(::isatty(::fileno(stdout)))
{
}

void hft_display_filter::display(const hft_forex_emulator::emulation_result &data)
{
    std::cout << "Column #1: Instrument ticker\n";
    std::cout << "Column #2: Position direction\n";
    std::cout << "Column #3: Pips yield\n";
    std::cout << "Column #4: Position volume\n";
    std::cout << "Columns #5,#6,#7: Time of open/close position\n";
    std::cout << "Column #8: Equity on account after close position (in account's currency)\n";
    std::cout << "Column #9: Total swap generated by the position\n";
    std::cout << "Column #10: Money yield including swaps (in account's currency)\n";
    std::cout << "Column #11: Percentage used of margin after close position\n";
    std::cout << "Column #12: Number of other open positions\n";

    int length = get_max_instrument_strlen(data);

    for (auto &x : data.trades)
    {
        print_string(x.instrument, length + 1);

        if (x.direction == hft::protocol::response::position_direction::POSITION_LONG)
        {
            std::cout << "LONG  ";
        }
        else
        {
            std::cout << "SHORT ";
        }

        print_number(x.pips_yield, 6);  std::cout << "  ";
        print_number(x.qty, 6);         std::cout << "  ";

        std::cout << boost::posix_time::to_simple_string(x.open_time) << " – " << boost::posix_time::to_simple_string(x.close_time) << "  ";

        print_number(x.equity, 10);     std::cout << "  ";
        print_number(x.total_swaps, 6); std::cout << "  ";
        print_number(x.money_yield, 6); std::cout << "  ";
        print_percent(x.used_margin_percentage); std::cout << "  ";

        std::cout << x.still_opened;

        if (x.closed_forcibly)
        {
            std::cout << " (forcibly closed)";
        }

        std::cout << "\n";
    }

    std::cout << "Additional info:\n";
    std::cout << "total withdrawn: " << data.total_withdrawn << "\n";
    std::cout << "min equity: " << data.min_equity << "\n";
    std::cout << "max equity: " << data.max_equity << "\n";

    if (data.bankrupt)
    {
        if (! is_tty_output_)
        {
            std::cout << "*** BANKRUPT ***\n";
        }
        else
        {
            std::cout << "\033[0;31m*** BANKRUPT ***\033[0m\n";
        }
    }
}

void hft_display_filter::print_number(double num, int len)
{
    std::string num_str = std::to_string(num);
    num_str.resize(len, ' ');

    if (! is_tty_output_)
    {
        std::cout << num_str;
    }
    else
    {
        if (num < 0.0)
        {
            std::cout << "\033[0;31m";
        }
        else
        {
            std::cout << "\033[0;32m";
        }

        std::cout << num_str << "\033[0m";
    }
}

void hft_display_filter::print_string(const std::string &s, int len)
{
    auto l = s.length();

    if (l > len)
    {
        std::cout << s.substr(0, len);

        return;
    }

    std::string completion(len - l, ' ');
    std::cout << s << completion;
}

void hft_display_filter::print_percent(int value)
{
    char buffer[] = { ' ', ' ', ' ', '%', '\0' };

    if (value < 0 || value > 999)
    {
        buffer[0] = buffer[1] = buffer[2] = buffer[3] = '-';
    }
    else
    {
        int index = 2;
        int c;

        do
        {
            c = value % 10;
            value /= 10;
            buffer[index--] = (char)(c+48);
        } while (value);
    }

    if (! is_tty_output_)
    {
        std::cout << buffer;
    }
    else
    {
        std::cout << "\033[0;33m" << buffer << "\033[0m";
    }
}

size_t hft_display_filter::get_max_instrument_strlen(const hft_forex_emulator::emulation_result &data)
{
    size_t maxl = 0;

    for (auto &x : data.trades)
    {
        if (x.instrument.length() > maxl)
        {
            maxl = x.instrument.length();
        }
    }

    return maxl;
}

